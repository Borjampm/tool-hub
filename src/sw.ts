/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

declare let self: ServiceWorkerGlobalScope;

// SyncEvent type for Background Sync API (not in standard TypeScript lib)
interface SyncEvent extends ExtendableEvent {
  readonly tag: string;
  readonly lastChance: boolean;
}

// Take control immediately
self.skipWaiting();
clientsClaim();

// Clean up old caches
cleanupOutdatedCaches();

// Precache all assets generated by the build
precacheAndRoute(self.__WB_MANIFEST);

// Cache Supabase API requests with NetworkFirst strategy
registerRoute(
  ({ url }) => url.hostname.includes('supabase.co'),
  new NetworkFirst({
    cacheName: 'supabase-api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// IndexedDB constants (must match offlineQueueService.ts)
const DB_NAME = 'tool-hub-offline';
const DB_VERSION = 1;
const STORE_NAME = 'pending-operations';

// Background Sync event handler
// Using type assertion since 'sync' event is not in standard TypeScript lib
(self as unknown as { addEventListener(type: 'sync', listener: (event: SyncEvent) => void): void })
  .addEventListener('sync', (event: SyncEvent) => {
    if (event.tag === 'offline-sync') {
      event.waitUntil(processOfflineQueue());
    }
  });

interface QueuedOperation {
  id: string;
  type: 'transaction' | 'timeEntry';
  action: 'create' | 'update' | 'delete';
  data: Record<string, unknown>;
  timestamp: number;
  retries: number;
}

async function openDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
        store.createIndex('timestamp', 'timestamp', { unique: false });
        store.createIndex('type', 'type', { unique: false });
      }
    };
  });
}

async function getPendingOperations(): Promise<QueuedOperation[]> {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([STORE_NAME], 'readonly');
    const store = transaction.objectStore(STORE_NAME);
    const index = store.index('timestamp');
    const request = index.getAll();
    request.onsuccess = () => resolve(request.result || []);
    request.onerror = () => reject(request.error);
  });
}

async function removeFromQueue(db: IDBDatabase, id: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([STORE_NAME], 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.delete(id);
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error);
  });
}

async function processOfflineQueue(): Promise<void> {
  console.log('[SW] Processing offline queue...');

  try {
    const operations = await getPendingOperations();
    if (operations.length === 0) {
      console.log('[SW] No pending operations');
      return;
    }

    console.log(`[SW] Found ${operations.length} pending operations`);
    const db = await openDB();

    for (const operation of operations) {
      try {
        await processOperation(operation);
        await removeFromQueue(db, operation.id);
        console.log(`[SW] Processed operation ${operation.id}`);
      } catch (error) {
        console.error(`[SW] Failed to process operation ${operation.id}:`, error);
        // Leave in queue for retry
      }
    }

    // Notify clients that sync is complete
    const clients = await self.clients.matchAll();
    clients.forEach((client) => {
      client.postMessage({ type: 'SYNC_COMPLETE' });
    });
  } catch (error) {
    console.error('[SW] Failed to process offline queue:', error);
    throw error; // Re-throw to signal sync failure
  }
}

async function processOperation(operation: QueuedOperation): Promise<void> {
  // Get Supabase URL and key from environment or fetch from main thread
  // For now, we'll make the API calls and let Supabase handle auth via cookies/tokens

  if (operation.type === 'transaction' && operation.action === 'create') {
    // This would need access to Supabase client
    // For Background Sync to work properly, we'd need to either:
    // 1. Store auth tokens in IndexedDB
    // 2. Use a backend endpoint that handles auth
    // For now, we'll just post a message to any open client to handle it
    const clients = await self.clients.matchAll();
    if (clients.length > 0) {
      clients[0].postMessage({
        type: 'PROCESS_QUEUED_OPERATION',
        operation,
      });
    }
    return;
  }

  if (operation.type === 'timeEntry' && operation.action === 'create') {
    const clients = await self.clients.matchAll();
    if (clients.length > 0) {
      clients[0].postMessage({
        type: 'PROCESS_QUEUED_OPERATION',
        operation,
      });
    }
    return;
  }
}

// Listen for messages from the main thread
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});
